<?php
require_once __DIR__ . '/../vendor/autoload.php';
require_once __DIR__ . '/../config/config.php';

use Square\SquareClient;
use Square\Environment;
use Square\Exceptions\ApiException;
use Square\Models\CreateOrderRequest;
use Square\Models\Order;
use Square\Models\OrderLineItem;
use Square\Models\Money;
use Square\Models\UpdateOrderRequest;

/**
 * Square API連携サービスクラス
 */
class SquareService {
    private $client;
    private $locationId;
    private static $logFile = null;
    private static $maxLogSize = 500 * 1024; // 500KB
    
    // 最近作成されたチケットを一時的に保存する静的変数
    private static $recentlyCreatedTickets = [];
    
    /**
     * コンストラクタ
     */
    public function __construct() {
        // ログファイルの初期化
        self::initLogFile();
        self::logMessage("SquareService::__construct - Square API接続初期化開始", 'INFO');
        
        $environment = SQUARE_ENVIRONMENT === 'production' 
            ? Environment::PRODUCTION 
            : Environment::SANDBOX;
            
        $this->client = new SquareClient([
            'accessToken' => SQUARE_ACCESS_TOKEN,
            'environment' => $environment,
            'timeout' => 10, // タイムアウト時間をさらに短く設定（以前は15秒）
            'connectTimeout' => 3, // 接続タイムアウトを3秒に設定（以前は5秒）
            'curlOptions' => [
                CURLOPT_SSL_VERIFYPEER => true, // SSL検証を有効化（安全）
                CURLOPT_SSL_VERIFYHOST => 2,    // ホスト検証も有効化（安全）
                CURLOPT_CAINFO => __DIR__ . '/../certificates/cacert.pem', // 証明書バンドルへのパス
                CURLOPT_VERBOSE => true         // 詳細なデバッグ情報を有効化
            ]
        ]);
        
        $this->locationId = SQUARE_LOCATION_ID;
        
        // API接続情報をログに記録
        self::logMessage("Square API設定情報: accessToken=" . substr(SQUARE_ACCESS_TOKEN, 0, 5) . "..., " .
                      "environment=" . $environment . ", " .
                      "timeout=10, connectTimeout=3, " .
                      "locationId=" . SQUARE_LOCATION_ID, 'INFO');
        
        self::logMessage("SquareService::__construct - Square API接続初期化完了 (環境: {$environment})", 'INFO');
    }
    
    /**
     * ログファイルの初期化
     */
    private static function initLogFile() {
        if (self::$logFile !== null) {
            return;
        }
        
        $logDir = __DIR__ . '/../../logs';
        if (!is_dir($logDir)) {
            mkdir($logDir, 0755, true);
        }
        
        self::$logFile = $logDir . '/SquareService.log';
        
        // ログローテーションのチェック
        self::checkLogRotation();
    }
    
    /**
     * ログローテーションのチェックと実行
     */
    private static function checkLogRotation() {
        if (!file_exists(self::$logFile)) {
            // ログファイルが存在しない場合は作成する
            $timestamp = date('Y-m-d H:i:s');
            $message = "[$timestamp] [INFO] ログファイル作成\n";
            file_put_contents(self::$logFile, $message);
            return;
        }
        
        // ファイルサイズを確認
        $fileSize = filesize(self::$logFile);
        if ($fileSize > self::$maxLogSize) {
            // 古いログファイルの名前を変更
            $backupFile = self::$logFile . '.' . date('Y-m-d_H-i-s');
            rename(self::$logFile, $backupFile);
            
            // 新しいログファイルを作成
            $timestamp = date('Y-m-d H:i:s');
            $message = "[$timestamp] [INFO] ログローテーション実行 - 前回ログ: $backupFile ($fileSize bytes)\n";
            file_put_contents(self::$logFile, $message);
        }
    }
    
    /**
     * ログメッセージをファイルに書き込む
     * 
     * @param string $message ログメッセージ
     * @param string $level ログレベル (INFO, WARNING, ERROR)
     */
    private static function logMessage($message, $level = 'INFO') {
        self::initLogFile();
        
        $timestamp = date('Y-m-d H:i:s');
        $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);
        $caller = isset($backtrace[1]['function']) ? $backtrace[1]['function'] : 'unknown';
        $file = isset($backtrace[0]['file']) ? basename($backtrace[0]['file']) : 'unknown';
        $line = isset($backtrace[0]['line']) ? $backtrace[0]['line'] : 0;
        
        $logMessage = "[$timestamp] [$level] [$file:$line->$caller] $message\n";
        
        // ログファイルへの書き込み
        file_put_contents(self::$logFile, $logMessage, FILE_APPEND);
    }
    
    /**
     * 引数の内容を文字列化する
     * 
     * @param mixed $args 引数
     * @return string 文字列化された引数
     */
    private static function formatArgs($args) {
        if (is_array($args)) {
            // 配列の場合は再帰的に処理
            $result = [];
            foreach ($args as $key => $value) {
                if (is_array($value)) {
                    // 配列が大きすぎる場合は要約
                    if (count($value) > 5) {
                        $result[$key] = '[配列: ' . count($value) . '件]';
                    } else {
                        $result[$key] = self::formatArgs($value);
                    }
                } elseif (is_object($value)) {
                    $result[$key] = '[オブジェクト: ' . get_class($value) . ']';
                } else {
                    $result[$key] = $value;
                }
            }
            return json_encode($result, JSON_UNESCAPED_UNICODE);
        } elseif (is_object($args)) {
            return '[オブジェクト: ' . get_class($args) . ']';
        } else {
            return json_encode($args, JSON_UNESCAPED_UNICODE);
        }
    }
    
    /**
     * 商品カタログを取得
     * 
     * @param bool $returnRawObjects trueの場合、Square APIから返されたオブジェクトをそのまま返す
     * @param int $maxResults 取得する最大商品数（最大200）
     * @return array 商品情報の配列
     */
    public function getItems($returnRawObjects = false, $maxResults = 200) {
        self::logMessage("getItems 開始: returnRawObjects=" . ($returnRawObjects ? "true" : "false") . ", maxResults={$maxResults}", 'INFO');
        
        try {
            $catalogApi = $this->client->getCatalogApi();
            $allObjects = [];
            $cursor = null;
            $pageCount = 0;
            $maxPages = ceil(min(200, $maxResults) / 100); // 最大2ページ（200件）まで取得

            do {
                self::logMessage("Square API 商品取得: ページ " . ($pageCount + 1) . " カーソル: " . ($cursor ?: "初回"), 'INFO');
                Utils::log("Square API 商品取得: ページ " . ($pageCount + 1) . " カーソル: " . ($cursor ?: "初回"), 'DEBUG', 'SquareService');
                $response = $catalogApi->listCatalog($cursor, "ITEM");
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                    $objects = $result->getObjects() ?? [];
                    $allObjects = array_merge($allObjects, $objects);
                    
                    // 次のページを取得するためのカーソルを設定
                    $cursor = $result->getCursor();
                    $pageCount++;
                    
                    self::logMessage("Square API 商品取得: ページ " . $pageCount . " で " . count($objects) . "件取得", 'INFO');
                    Utils::log("Square API 商品取得: ページ " . $pageCount . " で " . count($objects) . "件取得", 'DEBUG', 'SquareService');
                    
                    // 十分な数のアイテムを取得したか、または次のページがない場合は終了
                    if ($pageCount >= $maxPages || empty($cursor) || count($allObjects) >= $maxResults) {
                        break;
                    }
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return [];
            }
            } while (true);
            
            // 最大件数に制限
            if (count($allObjects) > $maxResults) {
                $allObjects = array_slice($allObjects, 0, $maxResults);
            }
            
            // オブジェクトをそのまま返す場合
            if ($returnRawObjects) {
                self::logMessage("Square APIから生のオブジェクト形式で商品を取得: " . count($allObjects) . "件", 'INFO');
                Utils::log("Square APIから生のオブジェクト形式で商品を取得: " . count($allObjects) . "件", 'DEBUG', 'SquareService');
                return $allObjects;
            }
            
            // 連想配列に変換して返す場合
            $items = [];
            
            // オブジェクトを連想配列に変換
            foreach ($allObjects as $object) {
                if ($object->getType() !== 'ITEM') {
                    continue;
                }
                
                $itemData = $object->getItemData();
                if (!$itemData) {
                    continue;
                }
                
                // 価格情報を取得（最初のバリエーションを使用）
                $price = 0;
                $variations = $itemData->getVariations();
                if ($variations && count($variations) > 0) {
                    $variation = $variations[0];
                    $variationData = $variation->getItemVariationData();
                    if ($variationData && $variationData->getPriceMoney()) {
                        // 日本円はそのままの金額を使用
                        $price = $variationData->getPriceMoney()->getAmount();
                    }
                }
                
                // 画像ID取得方法を修正
                $imageIds = [];
                
                // 新しい方法1: imageDataプロパティからの取得を試みる
                if (method_exists($object, 'getImageData') && $object->getImageData()) {
                    $imageId = $object->getImageData()->getId();
                    if ($imageId) {
                        $imageIds[] = $imageId;
                    }
                }
                // 新しい方法2: itemDataからの取得を試みる
                else if ($itemData && method_exists($itemData, 'getImageIds')) {
                    $imageIds = $itemData->getImageIds() ?? [];
                }
                // 新しい方法3: カスタム属性から取得を試みる
                else if ($itemData && method_exists($itemData, 'getCustomAttributeValues')) {
                    $customAttributes = $itemData->getCustomAttributeValues();
                    if ($customAttributes && isset($customAttributes['image_id'])) {
                        $imageIds[] = $customAttributes['image_id']->getStringValue();
                    }
                }
                // デバッグ用に記録
                if (empty($imageIds)) {
                    self::logMessage("No image IDs found for item: " . $itemData->getName(), 'INFO');
                    Utils::log("No image IDs found for item: " . $itemData->getName(), 'DEBUG', 'SquareService');
                }
                
                // 連想配列に変換
                $items[] = [
                    'id' => $object->getId(),
                    'name' => $itemData->getName(),
                    'description' => $itemData->getDescription() ?? '',
                    'price' => $price,
                    'variations' => count($variations ?? []),
                    'category_id' => $itemData->getCategoryId() ?? '',
                    'image_ids' => $imageIds
                ];
            }
            
            self::logMessage("Square APIから配列形式で商品を取得: " . count($items) . "件", 'INFO');
            Utils::log("Square APIから配列形式で商品を取得: " . count($items) . "件", 'DEBUG', 'SquareService');
            return $items;
        } catch (ApiException $e) {
            self::logMessage("Square API Exception: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        }
    }
    
    /**
     * 商品の在庫数を取得
     * 
     * @param array $catalogItemIds 商品IDの配列
     * @return array 在庫情報の配列
     */
    public function getInventoryCounts($catalogItemIds) {
        self::logMessage("getInventoryCounts 開始: " . (is_array($catalogItemIds) ? count($catalogItemIds) : 0) . "件の商品ID", 'INFO');
        
        if (empty($catalogItemIds)) {
            self::logMessage("No catalog item IDs provided for inventory count", 'WARNING');
            Utils::log("No catalog item IDs provided for inventory count", 'WARNING', 'SquareService');
            return [];
        }
        
        try {
            self::logMessage("在庫情報を取得中: " . count($catalogItemIds) . "件の商品", 'INFO');
            Utils::log("在庫情報を取得中: " . count($catalogItemIds) . "件の商品", 'DEBUG', 'SquareService');
            
            $inventoryApi = $this->client->getInventoryApi();
            
            // Square SDKの新しいバージョンに対応
            $request = new \Square\Models\BatchRetrieveInventoryCountsRequest();
            $request->setCatalogObjectIds($catalogItemIds);
            
            // APIリクエスト実行
            $response = $inventoryApi->batchRetrieveInventoryCounts($request);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $counts = $result->getCounts() ?? [];
                
                self::logMessage("在庫情報を取得完了: " . count($counts) . "件", 'INFO');
                Utils::log("在庫情報を取得完了: " . count($counts) . "件", 'DEBUG', 'SquareService');
                
                return $counts;
            } else {
                $errors = $response->getErrors();
                $errorDetail = json_encode($errors);
                self::logMessage("Square API Error when retrieving inventory: " . $errorDetail, 'ERROR');
                Utils::log("Square API Error when retrieving inventory: " . $errorDetail, 'ERROR', 'SquareService');
                
                // エラーコードに応じた処理
                foreach ($errors as $error) {
                    // カタログにアクセスできないエラー
                    if ($error->getCategory() === 'AUTHENTICATION_ERROR' || 
                        $error->getCategory() === 'AUTHORIZATION_ERROR') {
                        self::logMessage("Square API認証エラー: " . $error->getDetail(), 'ERROR');
                        Utils::log("Square API authentication error: " . $error->getDetail(), 'ERROR', 'SquareService');
                    }
                }
                return [];
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception in getInventoryCounts: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception in getInventoryCounts: " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        }
    }
    
    /**
     * 商品の在庫情報を取得（互換性のために維持）
     * 
     * @param array $catalogItemIds 商品IDの配列
     * @return array 在庫情報の配列
     */
    public function getInventory($catalogItemIds) {
        self::logMessage("getInventory 開始: " . (is_array($catalogItemIds) ? count($catalogItemIds) : 0) . "件の商品ID", 'INFO');
        
        // 在庫数を取得
        $counts = $this->getInventoryCounts($catalogItemIds);
        
        // 整形された在庫情報
        $inventory = [];
        
        // 在庫情報を整形
        foreach ($counts as $count) {
            $catalogObjectId = $count->getCatalogObjectId();
            
            // このアイテムを保存
            $inventory[$catalogObjectId] = [
                'catalog_object_id' => $catalogObjectId,
                'quantity' => $count->getQuantity(),
                'state' => $count->getState(),
                'updated_at' => $count->getCalculatedAt(),
                'location_id' => $count->getLocationId()
            ];
        }
        
        self::logMessage("在庫情報整形完了: " . count($inventory) . "件", 'INFO');
        return $inventory;
    }
    
    /**
     * 注文を作成
     * 
     * @param string $roomNumber 部屋番号
     * @param array $items 注文商品の配列 [['square_item_id' => 'xxx', 'quantity' => 1, 'note' => '...'], ...]
     * @param string $guestName ゲスト名（オプション）
     * @param string $note 注文全体の備考
     * @return array|false 成功時は注文情報、失敗時はfalse
     */
    public function createOrder($roomNumber, $items, $guestName = '', $note = '') {
        self::logMessage("createOrder 開始: roomNumber={$roomNumber}, guestName={$guestName}, items=" . 
                      (is_array($items) ? count($items) . "件" : "不正な形式"), 'INFO');
        
        try {
            $orderApi = $this->client->getOrdersApi();
            $lineItems = [];
            
            // 処理前にアイテムの形式を検証
            if (!is_array($items)) {
                self::logMessage("items パラメータが配列ではありません: " . gettype($items), 'ERROR');
                return false;
            }
            
            // 商品項目の処理時にエラーが発生した場合のログを強化
            self::logMessage("商品項目の処理開始: " . count($items) . "件", 'INFO');
            
            foreach ($items as $index => $item) {
                try {
                    $lineItem = new OrderLineItem($item['quantity']);
                    
                    // カタログオブジェクトIDを使わず、常に名前と価格で商品を登録
                    if (!empty($item['name'])) {
                        $lineItem->setName($item['name']);
                        
                        // 価格情報を設定
                        if (!empty($item['price']) && is_numeric($item['price'])) {
                            $money = new Money();
                            // 価格はセント単位で指定（100円→10000）
                            $money->setAmount((int)($item['price'] * 100));
                            $money->setCurrency('JPY');
                            
                            $lineItem->setBasePriceMoney($money);
                            self::logMessage("名前と価格でラインアイテム作成: 名前={$item['name']}, 価格={$item['price']}", 'INFO');
                        } else {
                            self::logMessage("商品に価格が指定されていないため、ゼロ価格で設定します", 'WARNING');
                            $money = new Money();
                            $money->setAmount(0);
                            $money->setCurrency('JPY');
                            $lineItem->setBasePriceMoney($money);
                        }
                    } else {
                        // 名前が設定できない場合は商品 + インデックスで代用
                        self::logMessage("商品名が不足しているため代替名を使用: 商品" . ($index+1), 'WARNING');
                        $lineItem->setName("商品" . ($index+1));
                        
                        // 価格情報を設定
                        if (!empty($item['price']) && is_numeric($item['price'])) {
                            $money = new Money();
                            $money->setAmount((int)($item['price'] * 100));
                            $money->setCurrency('JPY');
                            $lineItem->setBasePriceMoney($money);
                        } else {
                            $money = new Money();
                            $money->setAmount(0);
                            $money->setCurrency('JPY');
                            $lineItem->setBasePriceMoney($money);
                        }
                    }
                    
                    if (!empty($item['note'])) {
                        $lineItem->setNote($item['note']);
                    }
                    
                    $lineItems[] = $lineItem;
                } catch (\Throwable $itemEx) {
                    self::logMessage("商品項目 $index の処理中にエラー: " . $itemEx->getMessage(), 'ERROR');
                    // 項目をスキップして処理を継続
                    continue;
                }
            }
            
            // 有効なライン項目がない場合はエラー
            if (empty($lineItems)) {
                self::logMessage("有効な商品項目がありません", 'ERROR');
                return false;
            }
            
            $order = new Order($this->locationId);
            $order->setLineItems($lineItems);
            $order->setState('OPEN');
            $order->setReferenceId($roomNumber);
            
            // メタデータを追加して検索性を向上
            $metadata = [
                'room_number' => $roomNumber,
                'guest_name' => $guestName ?? '',
                'order_source' => 'mobile_order'
            ];
            $order->setMetadata($metadata);
            
            if (!empty($note)) {
                $order->setNote($note);
            }
            
            self::logMessage("注文の作成準備完了: lineItems=" . count($lineItems) . "件", 'INFO');
            
            $body = new CreateOrderRequest();
            $body->setOrder($order);
            $body->setIdempotencyKey(uniqid('order_', true));
            
            $response = $orderApi->createOrder($body);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $orderData = $result->getOrder();
                
                self::logMessage("Square Order Created: " . $orderData->getId(), 'INFO');
                
                return [
                    'square_order_id' => $orderData->getId(),
                    'total_amount' => $this->formatMoney($orderData->getTotalMoney()),
                    'status' => $orderData->getState()
                ];
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                
                // 詳細なエラーログを出力
                foreach ($errors as $error) {
                    self::logMessage("Square API Error 詳細: カテゴリ=" . $error->getCategory() . 
                               ", コード=" . $error->getCode() . 
                               ", 詳細=" . $error->getDetail() .
                               (method_exists($error, 'getField') ? ", フィールド=" . $error->getField() : ""), 
                               'ERROR');
                }
                
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return false;
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception in createOrder: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        } catch (\Throwable $e) {
            self::logMessage("予期せぬエラー(createOrder): " . $e->getMessage() . "\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("予期せぬエラー(createOrder): " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        }
    }
    
    /**
     * 注文情報を取得
     * 
     * @param string $orderId Square注文ID
     * @return array|false 成功時は注文情報、失敗時はfalse
     */
    public function getOrder($orderId) {
        try {
            $orderApi = $this->client->getOrdersApi();
            $response = $orderApi->retrieveOrder($orderId);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $orderData = $result->getOrder();
                
                return [
                    'square_order_id' => $orderData->getId(),
                    'total_amount' => $this->formatMoney($orderData->getTotalMoney()),
                    'status' => $orderData->getState(),
                    'created_at' => $orderData->getCreatedAt(),
                    'updated_at' => $orderData->getUpdatedAt()
                ];
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return false;
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        }
    }
    
    /**
     * 部屋番号に関連する注文を検索
     * 
     * @param string $roomNumber 部屋番号
     * @return array 注文情報の配列
     */
    public function searchOrdersByRoom($roomNumber) {
        try {
            self::logMessage("searchOrdersByRoom開始: roomNumber={$roomNumber}", 'INFO');
            $orderApi = $this->client->getOrdersApi();
            
            // メタデータを使用して検索（より柔軟な検索が可能）
            // SearchOrdersRequestオブジェクトを作成
            $request = new \Square\Models\SearchOrdersRequest();
            
            // ロケーションIDを設定
            $request->setLocationIds([$this->locationId]);
            
            // クエリフィルターを作成
            $filter = new \Square\Models\SearchOrdersFilter();
            
            // ソースフィルターを設定
            $sourceFilter = new \Square\Models\SearchOrdersSourceFilter();
            $sourceFilter->setSourceNames(['mobile_order']);
            $filter->setSourceFilter($sourceFilter);
            
            // 状態フィルターを設定 - バージョン差異に対応
            $stateFilter = null;
            try {
                self::logMessage("StateFilter作成試行(新メソッド)", 'INFO');
                // 新しいバージョン方式を試す
                $stateFilter = new \Square\Models\SearchOrdersStateFilter(['OPEN']);
                self::logMessage("StateFilter作成成功(新メソッド)", 'INFO');
            } catch (\Throwable $e) {
                self::logMessage("StateFilter新メソッド失敗: " . $e->getMessage() . ", 旧メソッドに切り替え", 'WARNING');
                // 古いバージョン方式にフォールバック
                $stateFilter = new \Square\Models\SearchOrdersStateFilter();
                $stateFilter->setStates(['OPEN']);
                self::logMessage("StateFilter作成成功(旧メソッド)", 'INFO');
            }
            
            $filter->setStateFilter($stateFilter);
            
            // クエリオブジェクトを作成
            $query = new \Square\Models\SearchOrdersQuery();
            $query->setFilter($filter);
            
            // クエリをリクエストに設定
            $request->setQuery($query);
            
            self::logMessage("検索リクエスト作成完了: room_number={$roomNumber}", 'INFO');
            
            $response = $orderApi->searchOrders($request);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $orders = $result->getOrders() ?? [];
                
                // メタデータフィルターが使えない場合は、結果をフィルタリング
                $filteredOrders = [];
                foreach ($orders as $order) {
                    $metadata = $order->getMetadata();
                    if ($metadata && isset($metadata['room_number']) && $metadata['room_number'] === $roomNumber) {
                        $filteredOrders[] = $order;
                    } elseif ($order->getReferenceId() === $roomNumber) {
                        $filteredOrders[] = $order;
                    }
                }
                $orders = $filteredOrders;
                
                $formattedOrders = [];
                foreach ($orders as $order) {
                    $formattedOrders[] = [
                        'square_order_id' => $order->getId(),
                        'total_amount' => $this->formatMoney($order->getTotalMoney()),
                        'status' => $order->getState(),
                        'created_at' => $order->getCreatedAt(),
                        'updated_at' => $order->getUpdatedAt()
                    ];
                }
                
                self::logMessage("検索結果: " . count($formattedOrders) . "件の注文を取得", 'INFO');
                return $formattedOrders;
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return [];
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        } catch (\Throwable $e) {
            self::logMessage("予期せぬエラー(searchOrdersByRoom): " . $e->getMessage() . "\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("予期せぬエラー(searchOrdersByRoom): " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        }
    }
    
    /**
     * Webhookの署名を検証
     * 
     * @param string $signatureHeader Squareから送信された署名ヘッダー
     * @param string $requestBody リクエストボディ
     * @return bool 署名が有効な場合はtrue
     */
    public function validateWebhookSignature($signatureHeader, $requestBody) {
        if (empty($signatureHeader) || empty(SQUARE_WEBHOOK_SIGNATURE_KEY)) {
            return false;
        }
        
        $signature = '';
        $timestamp = '';
        
        // 署名ヘッダーをパース
        $elements = explode(',', $signatureHeader);
        foreach ($elements as $element) {
            if (strpos($element, 't=') === 0) {
                $timestamp = substr($element, 2);
            } elseif (strpos($element, 'v1=') === 0) {
                $signature = substr($element, 3);
            }
        }
        
        if (empty($signature) || empty($timestamp)) {
            return false;
        }
        
        // 署名の検証
        $signatureKey = SQUARE_WEBHOOK_SIGNATURE_KEY;
        $stringToSign = $timestamp . '.' . $requestBody;
        $hmac = hash_hmac('sha256', $stringToSign, $signatureKey, false);
        
        return hash_equals($hmac, $signature);
    }
    
    /**
     * Money型をフォーマットして返す
     * 
     * @param Money|null $money Square MoneyまたはMoney互換のオブジェクト
     * @return float|int|null フォーマット済みの金額（円）
     */
    private function formatMoney($money) {
        // null または undefined の場合は0を返す
        if ($money === null) {
            return 0;
        }

        try {
            // Money型から値を取得
            $amount = $money->getAmount();
            
            // 単位がセント（=1/100円）で保存されているので、円表示に変換
            if (is_int($amount)) {
                return $amount / 100;
            }
            
            return $amount;
        } catch (Exception $e) {
            // エラー時は0を返す
            self::logMessage("金額の変換中にエラーが発生: " . $e->getMessage(), 'WARNING');
            return 0;
        }
    }
    
    /**
     * 画像IDから画像オブジェクトを取得
     * 
     * @param string $imageId 画像ID
     * @return object|null 画像オブジェクト、または取得失敗時はnull
     */
    public function getImageById($imageId) {
        try {
            $catalogApi = $this->client->getCatalogApi();
            $response = $catalogApi->retrieveCatalogObject($imageId);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                return $result->getObject();
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return null;
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return null;
        }
    }
    
    /**
     * Square APIへの接続テスト
     * 
     * @return array|bool 成功時は場所情報を含む配列、失敗時はfalse
     * @throws Exception 接続に失敗した場合
     */
    public function testConnection() {
        try {
            self::logMessage("Square API接続テスト開始", 'INFO');
            
            // 一時的にタイムアウトを短く設定したクライアントを作成
            $tempClient = new SquareClient([
                'accessToken' => SQUARE_ACCESS_TOKEN,
                'environment' => SQUARE_ENVIRONMENT === 'production' ? Environment::PRODUCTION : Environment::SANDBOX,
                'timeout' => 5, // 5秒でタイムアウト
                'connectTimeout' => 3, // 3秒で接続タイムアウト
                'curlOptions' => [
                    CURLOPT_SSL_VERIFYPEER => true, // SSL検証を有効化（安全）
                    CURLOPT_SSL_VERIFYHOST => 2,    // ホスト検証も有効化（安全）
                    CURLOPT_CAINFO => __DIR__ . '/../certificates/cacert.pem', // 証明書バンドルへのパス
                    CURLOPT_VERBOSE => true         // 詳細なデバッグ情報を有効化
                ]
            ]);
            
            // 最小限のAPIリクエストでテスト (Locationsより軽量なV1 Locations)
            $locationsApi = $tempClient->getLocationsApi();
            
            self::logMessage("API接続テスト - リクエスト送信開始", 'INFO');
            $apiStartTime = microtime(true);
            
            try {
                $result = $locationsApi->listLocations();
                $apiEndTime = microtime(true);
                $apiCallTime = round(($apiEndTime - $apiStartTime) * 1000); // ミリ秒単位
                
                self::logMessage("API接続テスト - リクエスト完了 ({$apiCallTime}ms)", 'INFO');
                
                if ($result->isSuccess()) {
                    $locations = $result->getResult()->getLocations();
                    
                    if (empty($locations)) {
                        self::logMessage("API接続テスト - 接続成功だが店舗情報なし", 'WARNING');
                        return [
                            'success' => true,
                            'message' => 'Connection successful but no locations found'
                        ];
                    }
                    
                    self::logMessage("API接続テスト - 成功 ({$apiCallTime}ms)", 'INFO');
                    return [
                        'success' => true,
                        'message' => 'Connection successful',
                        'response_time_ms' => $apiCallTime
                    ];
                } else {
                    $errors = $result->getErrors();
                    $errorMessage = "API Error: " . json_encode($errors);
                    self::logMessage("API接続テスト - APIエラー: {$errorMessage}", 'ERROR');
                    return false;
                }
            } catch (ApiException $e) {
                $apiEndTime = microtime(true);
                $apiCallTime = round(($apiEndTime - $apiStartTime) * 1000); // ミリ秒単位
                
                $errorMessage = "Square API Exception during connection test: " . $e->getMessage();
                self::logMessage("API接続テスト - 例外発生 ({$apiCallTime}ms): {$errorMessage}", 'ERROR');
                
                // 例外の詳細をログに記録
                self::logMessage("例外詳細: " . print_r($e, true), 'ERROR');
                
                // レスポンスボディが取得できれば記録
                if (method_exists($e, 'getResponseBody')) {
                    $responseBody = $e->getResponseBody();
                    if ($responseBody) {
                        self::logMessage("API Error Response Body: " . json_encode($responseBody), 'ERROR');
                    }
                }
                
                return false;
            }
        } catch (Exception $e) {
            $errorMessage = "一般例外 (testConnection): " . $e->getMessage();
            self::logMessage($errorMessage, 'ERROR');
            self::logMessage("例外詳細: " . print_r($e, true), 'ERROR');
            return false;
        }
    }
    
    /**
     * Square API クライアントを取得
     * 
     * @return SquareClient Square API クライアントインスタンス
     */
    public function getSquareClient() {
        return $this->client;
    }
    
    /**
     * 決済処理を実行
     * 
     * @param string $orderId 注文ID
     * @param float $amount 金額
     * @param string $sourceId カード支払いソースID（Square Web Payment SDKから取得したnonce）
     * @return array 決済結果情報
     * @throws Exception 決済処理に失敗した場合
     */
    public function processPayment($orderId, $amount, $sourceId) {
        if (empty($sourceId)) {
            throw new Exception("支払いソースIDが必要です。カード情報から有効なnonceを取得してください。");
        }
        
        try {
            // 支払いAPI
            $paymentsApi = $this->client->getPaymentsApi();
            
            // 金額オブジェクトの作成（日本円の場合は整数）
            $amountMoney = new \Square\Models\Money();
            $amountMoney->setAmount((int)$amount);
            $amountMoney->setCurrency('JPY');
            
            // 決済リクエストの作成
            $createPaymentRequest = new \Square\Models\CreatePaymentRequest(
                $sourceId,
                uniqid('payment_', true),
                $amountMoney
            );
            
            // 関連注文IDの設定
            $createPaymentRequest->setOrderId($orderId);
            
            // 受領書の設定
            // このメソッドは最新のSquare SDKでは利用できないため削除
            // $createPaymentRequest->setReceiptNumber('LACIS-' . substr(uniqid(), -6));
            $createPaymentRequest->setReceiptUrl(BASE_URL . '/receipts/' . $orderId);
            
            // メモの設定
            $createPaymentRequest->setNote('LacisMobileOrder - Room Order');
            
            // 決済実行
            $response = $paymentsApi->createPayment($createPaymentRequest);
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $payment = $result->getPayment();
                
                self::logMessage("Payment Created: " . $payment->getId(), 'INFO');
                
                // 支払い情報を返す
                return [
                    'success' => true,
                    'payment_id' => $payment->getId(),
                    'order_id' => $payment->getOrderId(),
                    'amount' => $this->formatMoney($payment->getAmountMoney()),
                    'status' => $payment->getStatus(),
                    'created_at' => $payment->getCreatedAt(),
                    'card_details' => $payment->getCardDetails() ? [
                        'card_brand' => $payment->getCardDetails()->getCard()->getCardBrand(),
                        'last_4' => $payment->getCardDetails()->getCard()->getLast4(),
                        'exp_month' => $payment->getCardDetails()->getCard()->getExpMonth(),
                        'exp_year' => $payment->getCardDetails()->getCard()->getExpYear()
                    ] : null,
                    'receipt_url' => $payment->getReceiptUrl()
                ];
            } else {
                $errors = $response->getErrors();
                $errorMessages = [];
                foreach ($errors as $error) {
                    $errorMessages[] = $error->getDetail();
                }
                throw new Exception(implode(", ", $errorMessages));
            }
        } catch (ApiException $e) {
            self::logMessage("Payment Processing Failed: " . $e->getMessage(), 'ERROR');
            throw new Exception("決済処理に失敗しました: " . $e->getMessage());
        }
    }
    
    /**
     * LINE User IDからguest_name情報を設定するメソッド
     * @param array &$metadata メタデータ配列（参照渡し）
     * @param string $lineUserId LINE User ID
     * @param string $roomNumber 部屋番号
     * @return bool 設定成功したかどうか
     */
    private function setupGuestNameFromLineUserId(&$metadata, $lineUserId, $roomNumber) {
        // 既にguest_nameが設定されている場合は何もしない
        if (!empty($metadata['guest_name'])) {
            return true;
        }

        try {
            // LINE User IDからuser_nameを取得
            if (!empty($lineUserId)) {
                self::logMessage("LINE User ID ({$lineUserId}) からユーザー情報取得を試行", 'INFO');
                
                // データベース接続を取得
                require_once __DIR__ . '/Database.php';
                $db = Database::getInstance()->getConnection();
                
                $stmt = $db->prepare("SELECT user_name FROM line_room_links WHERE line_user_id = ? AND is_active = 1 LIMIT 1");
                $stmt->execute([$lineUserId]);
                $userData = $stmt->fetch(\PDO::FETCH_ASSOC);
                
                if ($userData && !empty($userData['user_name'])) {
                    $metadata['guest_name'] = $userData['user_name'];
                    self::logMessage("LINE情報からguest_nameを設定: {$userData['user_name']}", 'INFO');
                    return true;
                }
            }
            
            // LINE User IDで取得できなかった場合は部屋番号から取得
            if (!empty($roomNumber)) {
                self::logMessage("部屋番号 ({$roomNumber}) からユーザー情報取得を試行", 'INFO');
                
                if (!isset($db)) {
                    require_once __DIR__ . '/Database.php';
                    $db = Database::getInstance()->getConnection();
                }
                
                $stmt = $db->prepare("SELECT user_name FROM line_room_links WHERE room_number = ? AND is_active = 1 ORDER BY updated_at DESC LIMIT 1");
                $stmt->execute([$roomNumber]);
                $roomData = $stmt->fetch(\PDO::FETCH_ASSOC);
                
                if ($roomData && !empty($roomData['user_name'])) {
                    $metadata['guest_name'] = $roomData['user_name'];
                    self::logMessage("部屋番号からguest_nameを設定: {$roomData['user_name']}", 'INFO');
                    return true;
                }
            }
            
            // どちらの方法でも取得できなかった場合
            $metadata['guest_name'] = "Guest_" . substr(md5($roomNumber . time()), 0, 8);
            self::logMessage("フォールバック: 自動生成したguest_nameを設定: {$metadata['guest_name']}", 'INFO');
            return true;
        } catch (Exception $e) {
            self::logMessage("guest_name設定中にエラー発生: " . $e->getMessage(), 'ERROR');
            // エラー時でも処理を継続するため、最低限の値を設定
            $metadata['guest_name'] = "Room" . $roomNumber;
            return false;
        }
    }
    
    /**
     * 部屋用の保留伝票を作成
     * 
     * @param string $roomNumber 部屋番号
     * @param string $guestName ゲスト名（オプション）
     * @param string $lineUserId LINE User ID（オプション）
     * @return array|false 成功時は保留伝票情報、失敗時はfalse
     */
    public function createRoomTicket($roomNumber, $guestName = '', $lineUserId = null) {
        try {
            self::logMessage("createRoomTicket 開始: roomNumber={$roomNumber}, guestName={$guestName}, lineUserId={$lineUserId}", 'INFO');
            
            if (empty($roomNumber)) {
                self::logMessage("部屋番号が指定されていません", 'ERROR');
                return false;
            }
            
            // よりシンプルな接続テスト - 完全なAPIリクエストではなくロケーションIDの検証のみ
            if (empty($this->locationId)) {
                self::logMessage("Square API locationId が設定されていません。設定を確認してください。", 'ERROR');
                Utils::log("Square API locationId が設定されていません", 'ERROR', 'SquareService');
                return false;
            }
            
            self::logMessage("Square API createRoomTicket 処理開始: locationId={$this->locationId}", 'INFO');
            
            // Square APIへの接続テストを先に実行
            self::logMessage("Square API接続テストを実行します", 'INFO');
            $testResult = $this->testConnection();
            if (!$testResult) {
                self::logMessage("Square API接続テストに失敗しました。接続設定を確認してください。", 'ERROR');
                Utils::log("Square API接続テスト失敗", 'ERROR', 'SquareService');
                // 接続テスト失敗時にもう少し詳細な情報を収集
                self::logMessage("API設定：" .
                               "location_id=" . $this->locationId . ", " .
                               "environment=" . SQUARE_ENVIRONMENT . ", " .
                               "証明書パス=" . __DIR__ . '/../certificates/cacert.pem', 'ERROR');
                
                // 証明書ファイルの存在確認
                $certPath = __DIR__ . '/../certificates/cacert.pem';
                if (file_exists($certPath)) {
                    self::logMessage("証明書ファイルは存在します：" . $certPath, 'INFO');
                    $certSize = filesize($certPath);
                    self::logMessage("証明書ファイルサイズ：" . $certSize . " バイト", 'INFO');
                } else {
                    self::logMessage("証明書ファイルが見つかりません：" . $certPath, 'ERROR');
                }
            } else {
                self::logMessage("Square API接続テスト成功: " . json_encode($testResult), 'INFO');
            }
            
            $orderApi = $this->client->getOrdersApi();
            
            // 部屋用の空の注文を作成
            $order = new Order($this->locationId);
            $order->setState('OPEN');
            $order->setReferenceId($roomNumber);
            
            // 空のライン項目配列を設定（Square API v30.0では必須）
            $order->setLineItems([]);
            
            // 空のフルフィルメント配列を設定（Square API v30.0では必要な場合がある）
            $order->setFulfillments([]);
            
            // LINE User IDの取得（パラメータから取得する）
            // パラメータで渡されていない場合はリクエストヘッダーから取得を試みる
            if (empty($lineUserId) && isset($_SERVER['HTTP_X_LINE_USER_ID'])) {
                $lineUserId = $_SERVER['HTTP_X_LINE_USER_ID'];
                self::logMessage("リクエストヘッダーからLINE User IDを取得: {$lineUserId}", 'INFO');
            }
            
            // メタデータを追加
            $metadata = [
                'room_number' => $roomNumber,
                'guest_name' => $guestName,
                'order_source' => 'mobile_order',
                'is_room_ticket' => 'true',
                'note' => "Room {$roomNumber} Order"  // 注記情報をメタデータに含める
            ];
            
            // メタデータにguest_nameが含まれているか確認し、なければLINE情報から設定
            if (empty($metadata['guest_name'])) {
                // guest_name自動設定
                $this->setupGuestNameFromLineUserId($metadata, $lineUserId, $roomNumber);
            }
            
            self::logMessage("注文メタデータを設定: " . json_encode($metadata), 'INFO');
            $order->setMetadata($metadata);
            
            // Square APIのメタデータバリデーション要件を満たすために追加のデバッグログを記録
            self::logMessage("修正後のメタデータ設定: " . json_encode($metadata), 'INFO');
            
            // べき等性キーを日時を含めた形式にして一意性を高める
            $idempotencyKey = 'room_ticket_' . $roomNumber . '_' . uniqid('', true) . '_' . time();
            self::logMessage("べき等性キー: {$idempotencyKey}", 'INFO');
            
            // リクエストオブジェクトを作成
            $body = new CreateOrderRequest();
            $body->setOrder($order);
            $body->setIdempotencyKey($idempotencyKey);
            
            // APIリクエストの詳細をロギング（デバッグ用）
            $debugRequestInfo = json_encode([
                'location_id' => $this->locationId,
                'idempotency_key' => $idempotencyKey,
                'order_reference_id' => $roomNumber,
                'has_line_items' => is_array($order->getLineItems()),
                'has_fulfillments' => is_array($order->getFulfillments()),
                'has_money_fields' => false // 金額フィールドは設定しないためfalse
            ]);
            self::logMessage("リクエスト詳細情報: " . $debugRequestInfo, 'INFO');
            
            self::logMessage("Square API createOrder リクエスト準備完了", 'INFO');
            Utils::log("Square API createOrderリクエスト準備完了: room={$roomNumber}", 'DEBUG', 'SquareService');
            
            try {
                // デバッグログを残す（HTTPクライアント設定確認のコードを削除）
                self::logMessage("Square API リクエスト実行前", 'INFO');
                
                // リクエスト直前にメタデータの最終検証を追加
                $metadata = $order->getMetadata();
                if (is_array($metadata)) {
                    // 特にguest_nameフィールドを検証
                    if (empty($metadata['guest_name']) || $metadata['guest_name'] === '') {
                        // 空の場合は自動的にデフォルト値を設定
                        $metadata['guest_name'] = 'Guest_' . uniqid();
                        self::logMessage("警告: guest_name が空のため自動設定: " . $metadata['guest_name'], 'WARNING');
                        // 更新したメタデータを設定
                        $order->setMetadata($metadata);
                        
                        // リクエスト内容を更新
                        $body->setOrder($order);
                        
                        self::logMessage("メタデータ再検証後の更新: " . json_encode($metadata), 'INFO');
                    }
                }
                
                // リクエストの実行
                self::logMessage("Square API createOrderリクエスト送信開始", 'INFO');
                $response = $orderApi->createOrder($body);
                self::logMessage("Square API createOrderリクエスト送信完了", 'INFO');
                
                if ($response->isSuccess()) {
                    $result = $response->getResult();
                    $orderData = $result->getOrder();
                    
                    $orderId = $orderData->getId();
                    self::logMessage("Room Ticket Created for Room {$roomNumber}: {$orderId}", 'INFO');
                    
                    // 作成したチケット情報を静的変数に保存（同期問題対策）
                    self::$recentlyCreatedTickets[$roomNumber] = [
                        'square_order_id' => $orderId,
                        'room_number' => $roomNumber,
                        'status' => $orderData->getState(),
                        'created_at' => $orderData->getCreatedAt(),
                        'timestamp' => time() // 作成時のタイムスタンプを記録
                    ];
                    self::logMessage("チケット情報をメモリに保存: room={$roomNumber}, id={$orderId}", 'INFO');
                    
                    $ticketData = [
                        'square_order_id' => $orderId,
                        'room_number' => $roomNumber,
                        'status' => $orderData->getState(),
                        'created_at' => $orderData->getCreatedAt()
                    ];
                    
                    self::logMessage("作成されたチケットデータ: " . json_encode($ticketData), 'INFO');
                    return $ticketData;
                } else {
                    $errors = $response->getErrors();
                    $errorDetails = [];
                    
                    foreach ($errors as $error) {
                        $errorDetails[] = [
                            'category' => $error->getCategory(),
                            'code' => $error->getCode(),
                            'detail' => $error->getDetail(),
                            'field' => method_exists($error, 'getField') ? $error->getField() : null
                        ];
                        
                        // より詳細なエラー情報を個別にログに記録
                        $errorMsg = "Square API Error: " . 
                            "Category=" . $error->getCategory() . 
                            ", Code=" . $error->getCode() . 
                            ", Detail=" . $error->getDetail();
                        
                        if (method_exists($error, 'getField') && $error->getField()) {
                            $errorMsg .= ", Field=" . $error->getField();
                        }
                        
                        self::logMessage($errorMsg, 'ERROR');
                        Utils::log($errorMsg, 'ERROR', 'SquareService');
                        
                        // MISSING_REQUIRED_PARAMETERエラーの場合、追加情報を取得
                        if ($error->getCode() === 'MISSING_REQUIRED_PARAMETER') {
                            // 実行中の関数名とリクエスト内容を詳細にログ
                            self::logMessage("必須パラメータエラー詳細 - 関数: createRoomTicket, " . 
                                "Order内容: " . json_encode([
                                    'state' => $order->getState(),
                                    'reference_id' => $order->getReferenceId(),
                                    'line_items_count' => is_array($order->getLineItems()) ? count($order->getLineItems()) : 'null',
                                    'fulfillments_count' => is_array($order->getFulfillments()) ? count($order->getFulfillments()) : 'null',
                                    'has_money_fields' => false, // 金額フィールドは設定しない
                                    'location_id' => $this->locationId,
                                    'metadata' => $order->getMetadata()
                                ]), 'ERROR');
                        }
                    }
                    
                    self::logMessage("Square API チケット作成エラー: " . json_encode($errorDetails), 'ERROR');
                    Utils::log("Square API チケット作成エラー: " . json_encode($errorDetails), 'ERROR', 'SquareService');
                    return false;
                }
            } catch (ApiException $e) {
                self::logMessage("Square API Exception during createOrder: " . $e->getMessage() . "\n" . $e->getTraceAsString(), 'ERROR');
                Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
                
                // レスポンスが取得できる場合は内容をログに記録
                $responseBody = $e->getResponseBody();
                if ($responseBody) {
                    $bodyJson = json_encode($responseBody);
                    self::logMessage("API Error Response: " . $bodyJson, 'ERROR');
                    Utils::log("API Error Response Body: " . $bodyJson, 'ERROR', 'SquareService');
                }
                
                // PHPのエラー情報も記録
                $lastError = error_get_last();
                if ($lastError) {
                    self::logMessage("最後のPHPエラー: " . json_encode($lastError), 'ERROR');
                }
                
                return false;
            }
        } catch (Exception $e) {
            self::logMessage("一般的な例外 (createRoomTicket): " . $e->getMessage() . "\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("一般的な例外: " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        }
    }
    
    /**
     * 部屋に関連付けられた保留伝票を取得
     * 
     * @param string $roomNumber 部屋番号
     * @return array|false 成功時は保留伝票情報、失敗時はfalse
     */
    public function getRoomTicket($roomNumber) {
        try {
            self::logMessage("getRoomTicket開始: roomNumber={$roomNumber}", 'INFO');
            
            // 部屋番号に関連する注文を検索
            $orders = $this->searchOrdersByRoom($roomNumber);
            
            // 検索結果のログ詳細
            if (empty($orders)) {
                self::logMessage("部屋 {$roomNumber} の注文が見つかりませんでした", 'WARNING');
                
                // APIで見つからない場合、最近作成されたチケットを確認する（同期問題対策）
                if (isset(self::$recentlyCreatedTickets[$roomNumber])) {
                    $recentTicket = self::$recentlyCreatedTickets[$roomNumber];
                    
                    // 作成から60秒以内のチケットのみ使用（古いチケットは除外）
                    $timeDiff = time() - $recentTicket['timestamp'];
                    if ($timeDiff <= 60) { // 1分以内
                        self::logMessage("メモリ内のチケット情報を使用: id={$recentTicket['square_order_id']}, 経過時間={$timeDiff}秒", 'INFO');
                        
                        // 直接Orderを取得
                        $orderDetails = $this->getOrder($recentTicket['square_order_id']);
                        
                        if ($orderDetails) {
                            // 最新情報を取得できた場合
                            self::logMessage("メモリ内チケットの最新情報を取得: " . json_encode($orderDetails), 'INFO');
                            return $orderDetails;
                        } else {
                            // メモリ内データだけでチケット情報を構築
                            self::logMessage("メモリ内チケット情報で応答: " . json_encode($recentTicket), 'INFO');
                            return [
                                'square_order_id' => $recentTicket['square_order_id'],
                                'room_number' => $roomNumber,
                                'status' => $recentTicket['status'],
                                'total_amount' => 0, // メモリ内には金額情報がないため0
                                'created_at' => $recentTicket['created_at'],
                                'updated_at' => $recentTicket['created_at'],
                                'line_items' => [] // メモリ内には商品情報がないため空
                            ];
                        }
                    } else {
                        // 古いチケット情報は使用しない
                        self::logMessage("メモリ内のチケット情報が古いため使用しません: 経過時間={$timeDiff}秒", 'WARNING');
                    }
                }
                
                return false;
            }
            
            self::logMessage("searchOrdersByRoomから取得した注文数: " . count($orders), 'INFO');
            
            // 開いている注文がない場合はfalseを返す
            if (empty($orders)) {
                return false;
            }
            
            // メタデータで「is_room_ticket」が「true」の注文をフィルタリング
            foreach ($orders as $order) {
                try {
                    self::logMessage("注文詳細を取得: " . $order['square_order_id'], 'INFO');
                    $orderDetails = $this->getOrder($order['square_order_id']);
                    
                    if (!$orderDetails) {
                        self::logMessage("注文詳細が取得できませんでした: " . $order['square_order_id'], 'WARNING');
                        continue;
                    }
                    
                    $orderApi = $this->client->getOrdersApi();
                    $response = $orderApi->retrieveOrder($order['square_order_id']);
                    
                    if ($response->isSuccess()) {
                        $result = $response->getResult();
                        $orderData = $result->getOrder();
                        $metadata = $orderData->getMetadata();
                        
                        if (isset($metadata['is_room_ticket']) && $metadata['is_room_ticket'] === 'true') {
                            // 保留伝票の情報を返す
                            $ticket = [
                                'square_order_id' => $orderData->getId(),
                                'room_number' => $roomNumber,
                                'status' => $orderData->getState(),
                                'total_amount' => $this->formatMoney($orderData->getTotalMoney()),
                                'created_at' => $orderData->getCreatedAt(),
                                'updated_at' => $orderData->getUpdatedAt(),
                                'line_items' => $this->formatLineItems($orderData->getLineItems())
                            ];
                            self::logMessage("部屋 {$roomNumber} の有効なチケットを発見: " . $ticket['square_order_id'], 'INFO');
                            return $ticket;
                        }
                    } else {
                        $errors = $response->getErrors();
                        self::logMessage("注文詳細の取得中にエラー: " . json_encode($errors), 'ERROR');
                    }
                } catch (\Throwable $e) {
                    self::logMessage("注文処理中に例外発生: " . $e->getMessage(), 'ERROR');
                    // 次の注文を処理するために続行
                    continue;
                }
            }
            
            self::logMessage("部屋 {$roomNumber} に有効なチケットが見つかりませんでした", 'WARNING');
            return false;
        } catch (ApiException $e) {
            self::logMessage("Square API Exception in getRoomTicket: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        } catch (\Throwable $e) {
            self::logMessage("予期せぬエラー(getRoomTicket): " . $e->getMessage() . "\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("予期せぬエラー(getRoomTicket): " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        }
    }
    
    /**
     * 保留伝票に商品を追加
     * 
     * @param string $roomNumber 部屋番号
     * @param array $items 追加する商品の配列 [['square_item_id' => 'xxx', 'quantity' => 1, 'note' => '...'], ...]
     * @return array|false 成功時は更新された保留伝票情報、失敗時はfalse
     */
    public function addItemToRoomTicket($roomNumber, $items) {
        self::logMessage("addItemToRoomTicket 開始: roomNumber={$roomNumber}, items=" . 
                      (is_array($items) ? count($items) . "件" : "不正な形式"), 'INFO');
        
        try {
            // パラメータチェック
            if (empty($roomNumber)) {
                self::logMessage("部屋番号が指定されていません", 'ERROR');
                return false;
            }
            
            // itemsが文字列の場合はJSONデコード（配列全体が文字列として渡された場合）
            if (is_string($items)) {
                try {
                    $items = json_decode($items, true);
                    if (!is_array($items)) {
                        self::logMessage("商品データのJSONデコードに失敗しました: " . $items, 'ERROR');
                        return false;
                    }
                    self::logMessage("商品データ全体をJSONデコードしました: " . count($items) . "件", 'INFO');
                } catch (Exception $e) {
                    self::logMessage("商品データのJSONデコード中にエラー: " . $e->getMessage(), 'ERROR');
                    return false;
                }
            }
            
            // 配列でない場合はエラー
            if (!is_array($items)) {
                self::logMessage("商品データが配列ではありません: " . gettype($items), 'ERROR');
                return false;
            }
            
            // デバッグ: 項目ごとのデータ型を確認
            self::logMessage("商品データの型: " . json_encode(array_map(function($item) { 
                return is_array($item) ? 'array' : gettype($item); 
            }, $items)), 'INFO');
            
            // 正規化された商品アイテムの配列を作成
            $processedItems = [];
            
            foreach ($items as $index => $item) {
                // オリジナルのitemデータを保持
                $originalItem = $item;
                
                // 文字列の場合はデコード試行
                if (is_string($item)) {
                    try {
                        $decodedItem = json_decode($item, true);
                        
                        // JSONデコードが成功し、かつ配列である場合
                        if (is_array($decodedItem)) {
                            $item = $decodedItem;
                            
                            // square_item_idをロギング
                            if (isset($item['square_item_id'])) {
                                self::logMessage("アイテム[$index]をJSONデコードしました。square_item_id: " . $item['square_item_id'], 'INFO');
                            } else {
                                self::logMessage("アイテム[$index]をJSONデコードしましたが、square_item_idがありません", 'WARNING');
                            }
                        } else {
                            // デコードに失敗した場合は正規表現で抽出を試みる
                            if (preg_match('/square_item_id[\"\']?\s*:\s*[\"\']([^\"\']+)[\"\']/', $item, $matches)) {
                                $square_item_id = $matches[1];
                                $quantity = 1;
                                
                                // 数量も抽出を試みる
                                if (preg_match('/quantity[\"\']?\s*:\s*(\d+)/', $item, $qMatches)) {
                                    $quantity = (int)$qMatches[1];
                                }
                                
                                $item = [
                                    'square_item_id' => $square_item_id,
                                    'quantity' => $quantity,
                                    'note' => ''
                                ];
                                self::logMessage("アイテム[$index]を正規表現で抽出しました: square_item_id={$square_item_id}, quantity={$quantity}", 'INFO');
                            } else {
                                self::logMessage("アイテム[$index]の処理に失敗しました: " . $item, 'ERROR');
                                continue; // このアイテムはスキップ
                            }
                        }
                    } catch (Exception $e) {
                        self::logMessage("アイテム[$index]の処理中にエラー: " . $e->getMessage(), 'ERROR');
                        continue; // このアイテムはスキップ
                    }
                }
                
                // 配列でない場合はスキップ
                if (!is_array($item)) {
                    self::logMessage("アイテム[$index]が配列ではありません: " . gettype($item), 'ERROR');
                    continue;
                }
                
                // 必須フィールドのチェック - square_item_idまたはname+priceの組み合わせを許可
                $hasSquareId = isset($item['square_item_id']) && !empty($item['square_item_id']);
                $hasNameAndPrice = isset($item['name']) && !empty($item['name']) && isset($item['price']);
                
                if (!$hasSquareId && !$hasNameAndPrice) {
                    self::logMessage("アイテム[$index]に必要な識別情報がありません。square_item_idまたはname+priceの組み合わせが必要です", 'ERROR');
                    continue;
                }
                
                // 数量のチェック
                if (!isset($item['quantity']) || !is_numeric($item['quantity']) || $item['quantity'] <= 0) {
                    $item['quantity'] = 1; // デフォルト値
                    self::logMessage("アイテム[$index]の数量が無効なため、デフォルト値(1)を使用します", 'WARNING');
                }
                
                // 備考のチェック
                if (!isset($item['note'])) {
                    $item['note'] = '';
                }
                
                // 処理済みアイテムとして追加（すべての情報を含める）
                $processedItem = [
                    'quantity' => (int)$item['quantity'],
                    'note' => $item['note']
                ];
                
                // square_item_idがある場合は追加
                if ($hasSquareId) {
                    $processedItem['square_item_id'] = $item['square_item_id'];
                }
                
                // nameとpriceがある場合は追加
                if ($hasNameAndPrice) {
                    $processedItem['name'] = $item['name'];
                    $processedItem['price'] = is_numeric($item['price']) ? floatval($item['price']) : 0;
                }
                
                // 文字列からデコードした場合、元の文字列にsquare_item_idが含まれているか確認
                if (!isset($processedItem['square_item_id']) && is_string($originalItem)) {
                    // 正規表現でsquare_item_idを抽出
                    if (preg_match('/square_item_id[\"\']?\s*:\s*[\"\']([^\"\']+)[\"\']/', $originalItem, $matches)) {
                        $processedItem['square_item_id'] = $matches[1];
                        self::logMessage("アイテム[$index]の元の文字列からsquare_item_idを抽出: " . $matches[1], 'INFO');
                    }
                }
                
                $processedItems[] = $processedItem;
            }
            
            // 処理可能なアイテムがない場合
            if (empty($processedItems)) {
                self::logMessage("処理可能な商品がありません", 'ERROR');
                return false;
            }
            
            self::logMessage("処理済み商品アイテム: " . json_encode($processedItems), 'INFO');
            
            // データ変換後にsquare_item_idが保持されているか確認
            foreach ($processedItems as $index => $item) {
                // 元のitemsからsquare_item_idを確認
                if (!isset($item['square_item_id']) && is_array($items[$index]) && isset($items[$index]['square_item_id'])) {
                    $processedItems[$index]['square_item_id'] = $items[$index]['square_item_id'];
                    self::logMessage("アイテム[$index]にsquare_item_idを復元しました: " . $items[$index]['square_item_id'], 'INFO');
                }
            }
            
            // 部屋の保留伝票を取得（リトライロジックを追加）
            $ticket = null;
            $maxRetries = 2; // 最大リトライ回数
            
            for ($retry = 0; $retry <= $maxRetries; $retry++) {
                if ($retry > 0) {
                    // リトライの場合は少し待機してから再試行
                    $waitTime = $retry * 1; // 1秒、2秒...と増加
                    self::logMessage("チケット取得リトライ #{$retry}: {$waitTime}秒待機", 'INFO');
                    sleep($waitTime);
                }
                
                $ticket = $this->getRoomTicket($roomNumber);
                
                if ($ticket) {
                    self::logMessage("チケット取得成功: " . self::formatArgs($ticket) . ($retry > 0 ? "（リトライ#{$retry}で成功）" : "（初回で成功）"), 'INFO');
                    break; // チケットが取得できたらループを抜ける
                } else if ($retry == $maxRetries) {
                    self::logMessage("すべてのリトライ({$maxRetries}回)失敗後もチケットが取得できませんでした", 'ERROR');
                }
            }
            
            // 保留伝票が存在しない場合は作成
            if (!$ticket) {
                self::logMessage("Room {$roomNumber} の保留伝票が存在しないため、新規作成します", 'INFO');
                $ticket = $this->createRoomTicket($roomNumber);
                
                if (!$ticket) {
                    self::logMessage("Failed to create room ticket for room {$roomNumber}", 'ERROR');
                    return false;
                }
                
                self::logMessage("Room {$roomNumber} の保留伝票を作成しました: " . self::formatArgs($ticket), 'INFO');
                
                // 作成したチケットのSquare側の情報を取得
                if (!isset($ticket['square_order_id'])) {
                    self::logMessage("作成したチケットにSquare注文IDがありません", 'ERROR');
                    return false;
                }
                
                // Square APIから情報を取得して追加
                $squareTicket = $this->getOrder($ticket['square_order_id']);
                if ($squareTicket) {
                    $ticket['square_data'] = $squareTicket;
                } else {
                    self::logMessage("Square APIから注文情報を取得できませんでした: " . $ticket['square_order_id'], 'ERROR');
                    // エラーログを記録するが処理は続行する
                }
            }
            
            // 保留伝票が存在する場合は、既存の注文に商品を追加
            $orderApi = $this->client->getOrdersApi();
            $orderId = $ticket['square_order_id'];
            self::logMessage("更新対象の注文ID: {$orderId}", 'INFO');
            
            // 注文バージョンを取得
            try {
            $response = $orderApi->retrieveOrder($orderId);
            
            if (!$response->isSuccess()) {
                $errors = $response->getErrors();
                    $errorMsg = "Failed to retrieve order for update: " . json_encode($errors);
                    self::logMessage($errorMsg, 'ERROR');
                    Utils::log($errorMsg, 'ERROR', 'SquareService');
                    
                    // エラー詳細のログ
                    foreach ($errors as $error) {
                        self::logMessage("Square API Error: Category={$error->getCategory()}, Code={$error->getCode()}, Detail={$error->getDetail()}", 'ERROR');
                    }
                    
                return false;
            }
            
            $result = $response->getResult();
            $orderData = $result->getOrder();
                
                if (!$orderData) {
                    self::logMessage("注文データがnullです。SquareのAPIは成功しましたが、データがありません。", 'ERROR');
                    return false;
                }
                
            $version = $orderData->getVersion();
                if ($version === null) {
                    self::logMessage("注文バージョンがnullです: orderId={$orderId}", 'ERROR');
                    return false;
                }
                
                self::logMessage("注文バージョン: {$version}", 'INFO');
            
            // 既存のライン項目を取得して保持
            $existingLineItems = $orderData->getLineItems() ?? [];
                self::logMessage("既存のライン項目数: " . count($existingLineItems), 'INFO');
            
            // 商品ラインアイテムを作成
            $lineItems = [];
            
            // 既存のライン項目を保持
            foreach ($existingLineItems as $existingItem) {
                $lineItems[] = $existingItem;
            }
            
            // 新しいライン項目を追加
            foreach ($processedItems as $item) {
                try {
                        if (!isset($item['square_item_id']) || empty($item['square_item_id'])) {
                            // カタログIDがない場合は名前と価格が必要
                            if (empty($item['name'])) {
                                self::logMessage("商品IDと名前の両方がありません: " . self::formatArgs($item), 'ERROR');
                                continue;
                            }
                        }
                        
                        $quantity = isset($item['quantity']) ? (int)$item['quantity'] : 1;
                        if ($quantity <= 0) {
                            self::logMessage("無効な数量: {$quantity}", 'ERROR');
                            $quantity = 1;
                        }
                        
                        self::logMessage("新しいOrderLineItemを作成開始", 'INFO');
                        
                        try {
                            $lineItem = new OrderLineItem($quantity);
                            $useNameAndPrice = false;
                            
                            // カタログオブジェクトIDがある場合はそれを使用
                            if (!empty($item['square_item_id'])) {
                                try {
                                    // カタログIDを使ってラインアイテムを作成
                    $lineItem->setCatalogObjectId($item['square_item_id']);
                                    self::logMessage("カタログIDでラインアイテム作成: {$item['square_item_id']}", 'INFO');
                                } catch (Exception $e) {
                                    // カタログIDでエラーが発生した場合、名前と価格を使用するフォールバック
                                    self::logMessage("カタログID使用中にエラー発生: {$e->getMessage()}, 名前と価格を使用します", 'WARNING');
                                    $useNameAndPrice = true;
                                }
                            } else {
                                // カタログIDがない場合は名前と価格を直接指定
                                $useNameAndPrice = true;
                            }
                            
                            // 名前と価格で指定（カタログIDがない場合またはエラー発生時）
                            if ($useNameAndPrice) {
                                if (!empty($item['name'])) {
                                    $lineItem->setName($item['name']);
                                    
                                    // 価格情報を設定
                                    if (isset($item['price']) && is_numeric($item['price'])) {
                                        $money = new Money();
                                        // 価格はセント単位で指定（100円→10000）
                                        $money->setAmount((int)($item['price'] * 100));
                                        $money->setCurrency('JPY');
                                        
                                        $lineItem->setBasePriceMoney($money);
                                        self::logMessage("名前と価格でラインアイテム作成: 名前={$item['name']}, 価格={$item['price']}", 'INFO');
                                    } else {
                                        self::logMessage("商品に価格が指定されていないため、ゼロ価格で設定します", 'WARNING');
                                        $money = new Money();
                                        $money->setAmount(0);
                                        $money->setCurrency('JPY');
                                        $lineItem->setBasePriceMoney($money);
                                    }
                                } else {
                                    // 名前も設定できない場合は例外をスロー
                                    throw new Exception("カタログIDも商品名も指定されていません");
                                }
                            }
                    
                    if (!empty($item['note'])) {
                        $lineItem->setNote($item['note']);
                    }
                    
                    $lineItems[] = $lineItem;
                            self::logMessage("OrderLineItemを作成完了: " . (isset($item['square_item_id']) ? "ID={$item['square_item_id']}" : "名前={$item['name']}") . ", quantity={$quantity}", 'INFO');
                        } catch (Exception $e) {
                            self::logMessage("OrderLineItem作成中に例外発生: " . $e->getMessage() . "\nスタックトレース:\n" . $e->getTraceAsString(), 'ERROR');
                            Utils::log("OrderLineItem作成中に例外発生: " . $e->getMessage(), 'ERROR', 'SquareService');
                            
                            // 商品名と価格によるフォールバックをまだ試していない場合は試行
                            if (!empty($item['name']) && !isset($tried_fallback)) {
                                $tried_fallback = true;
                                self::logMessage("代替手段として商品名と価格を使用します: {$item['name']}", 'INFO');
                                
                                $lineItem = new OrderLineItem($quantity);
                                $lineItem->setName($item['name']);
                                
                                // 価格情報を設定
                                if (!empty($item['price']) && is_numeric($item['price'])) {
                                    $money = new Money();
                                    $money->setAmount((int)($item['price'] * 100));
                                    $money->setCurrency('JPY');
                                    
                                    $lineItem->setBasePriceMoney($money);
                                }
                                
                                if (!empty($item['note'])) {
                                    $lineItem->setNote($item['note']);
                                }
                                
                                $lineItems[] = $lineItem;
                                self::logMessage("フォールバック方法でOrderLineItemを作成完了", 'INFO');
                            }
                        }
                    } catch (Exception $e) {
                        self::logMessage("商品アイテム処理中に例外発生: " . $e->getMessage() . "\nスタックトレース:\n" . $e->getTraceAsString(), 'ERROR');
                        Utils::log("商品アイテム処理中に例外発生: " . $e->getMessage(), 'ERROR', 'SquareService');
                        continue;
                    }
                }
                
                // 処理可能な項目がない場合
                if (count($lineItems) === 0) {
                    self::logMessage("追加された新しい商品項目がありません", 'ERROR');
                    return false;
                }
                
                // 注文更新リクエストの作成
            try {
                $updateOrderRequest = new UpdateOrderRequest();
                    $updateOrderRequest->setOrder($orderData);
                    $updateOrderRequest->setIdempotencyKey(uniqid('update_', true));
                    
                    self::logMessage("UpdateOrderRequestオブジェクト作成完了: idempotencyKey=" . $updateOrderRequest->getIdempotencyKey(), 'INFO');
                    
                    // Square APIで注文更新
                    self::logMessage("Square APIで注文更新開始: orderId={$orderId}", 'INFO');
                    $response = $orderApi->updateOrder($orderId, $updateOrderRequest);
                    
                    if ($response->isSuccess()) {
                        self::logMessage("Square注文更新成功: orderId={$orderId}", 'INFO');
                        
                        // 更新された注文情報を取得
                        $updatedOrder = $response->getResult()->getOrder();
                        
                        // 成功時は更新された注文情報を返す
                        $result = [
                        'square_order_id' => $updatedOrder->getId(),
                        'status' => $updatedOrder->getState(),
                            'updated_at' => $updatedOrder->getUpdatedAt()
                    ];
                        
                        self::logMessage("Room ticket updated successfully: " . json_encode($result), 'INFO');
                        return $result;
                } else {
                        $errors = $response->getErrors();
                        $errorDetails = [];
                    
                    foreach ($errors as $error) {
                            $errorDetails[] = [
                                'category' => $error->getCategory(),
                                'code' => $error->getCode(),
                                'detail' => $error->getDetail()
                            ];
                        }
                        
                        self::logMessage("Square API注文更新エラー: " . json_encode($errorDetails), 'ERROR');
                        Utils::log("Square API注文更新エラー: " . json_encode($errorDetails), 'ERROR', 'SquareService');
                    return false;
                }
                } catch (Exception $e) {
                    self::logMessage("注文更新リクエスト作成またはAPI呼び出し中に例外発生: " . $e->getMessage() . "\nスタックトレース:\n" . $e->getTraceAsString(), 'ERROR');
                    Utils::log("注文更新リクエスト中に例外発生: " . $e->getMessage(), 'ERROR', 'SquareService');
                return false;
                }
            } catch (Exception $retrieveEx) {
                self::logMessage("注文取得エラー: " . $retrieveEx->getMessage() . "\n" . $retrieveEx->getTraceAsString(), 'ERROR');
                Utils::log("注文取得エラー: " . $retrieveEx->getMessage(), 'ERROR', 'SquareService');
                throw $retrieveEx;
            }
        } catch (ApiException $e) {
            self::logMessage("Square API例外: " . $e->getMessage() . "\nスタックトレース:\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("Square API例外: " . $e->getMessage(), 'ERROR', 'SquareService');
            
            // API ResponseBodyを取得できれば詳細ログに出力
            if ($e->getResponseBody()) {
                self::logMessage("Square API詳細レスポンス: " . json_encode($e->getResponseBody()), 'ERROR');
            }
            
            return false;
        } catch (Exception $e) {
            self::logMessage("予期せぬ例外: " . $e->getMessage() . "\nスタックトレース:\n" . $e->getTraceAsString(), 'ERROR');
            Utils::log("予期せぬ例外: " . $e->getMessage(), 'ERROR', 'SquareService');
            return false;
        }
    }
    
    /**
     * 最後のエラーメッセージを取得
     * 
     * @return string エラーメッセージ
     */
    private function getLastErrorMessage() {
        $logPath = __DIR__ . '/../../logs/SquareService.log';
        if (file_exists($logPath)) {
            $lastLines = shell_exec('tail -10 ' . $logPath);
            return $lastLines ?? 'エラーログが取得できません';
        }
        return 'エラーログファイルが存在しません';
    }
    
    /**
     * 注文の商品リストをフォーマット
     * 
     * @param array $lineItems 注文商品リスト
     * @return array フォーマット済み商品リスト
     */
    private function formatLineItems($lineItems) {
        if (!$lineItems) {
            return [];
        }
        
        $formattedItems = [];
        try {
            foreach ($lineItems as $item) {
                // 安全に値を取得
                $formattedItem = [
                    'uid' => $item->getUid() ?? '',
                    'name' => $item->getName() ?? 'Unknown Item',
                    'quantity' => $item->getQuantity() ?? 0,
                    'base_price_money' => $this->formatMoney($item->getBasePriceMoney()),
                    'variation_name' => $item->getVariationName() ?? '',
                    'note' => $item->getNote() ?? ''
                ];
                
                $formattedItems[] = $formattedItem;
            }
        } catch (\Throwable $e) {
            self::logMessage("LineItems処理中にエラー: " . $e->getMessage(), 'ERROR');
            // エラー発生時でも空の配列は返す
        }
        
        return $formattedItems;
    }
    
    /**
     * カテゴリ一覧を取得
     * 
     * @return array カテゴリ情報の配列 [['id' => 'xxx', 'name' => 'カテゴリ名'], ...]
     */
    public function getCategories() {
        try {
            self::logMessage("Square APIからカテゴリ取得開始", 'INFO');
            $catalogApi = $this->client->getCatalogApi();
            $response = $catalogApi->listCatalog(null, "CATEGORY");
            
            if ($response->isSuccess()) {
                $result = $response->getResult();
                $objects = $result->getObjects() ?? [];
                $categories = [];
                
                foreach ($objects as $object) {
                    if ($object->getType() !== 'CATEGORY') {
                        continue;
                    }
                    
                    $categoryData = $object->getCategoryData();
                    if (!$categoryData) {
                        continue;
                    }
                    
                    // カテゴリIDと名前を取得（重要）
                    $categories[] = [
                        'id' => $object->getId(),
                        'name' => $categoryData->getName() ?? 'カテゴリ' . count($categories)
                    ];
                }
                
                self::logMessage("Square APIからカテゴリ取得成功: " . count($categories) . "件", 'INFO');
                return $categories;
            } else {
                $errors = $response->getErrors();
                self::logMessage("Square API Error: " . json_encode($errors), 'ERROR');
                Utils::log("Square API Error: " . json_encode($errors), 'ERROR', 'SquareService');
                return [];
            }
        } catch (ApiException $e) {
            self::logMessage("Square API Exception: " . $e->getMessage(), 'ERROR');
            Utils::log("Square API Exception: " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        }
    }
    
    /**
     * カテゴリ一覧を取得（データベースから）
     * 
     * @return array カテゴリ情報の配列、またはエラー時は空配列
     */
    public function listCategories() {
        self::logMessage("listCategories 開始（データベースから取得）", 'INFO');
        
        try {
            // データベースからカテゴリを取得
            require_once __DIR__ . '/Database.php';
            $db = Database::getInstance();
            
            // カテゴリテーブルからデータを取得
            $categories = $db->select("SELECT id, category_id as square_id, name FROM category_descriptor WHERE is_active = 1");
            
            if (is_array($categories) && count($categories) > 0) {
                self::logMessage("データベースからカテゴリ取得成功: " . count($categories) . "件", 'INFO');
                
                // ProductServiceが期待する形式に変換
                $objects = [];
                foreach ($categories as $category) {
                    $objects[] = [
                        'id' => $category['square_id'] ?? $category['id'],
                        'category_data' => [
                            'name' => $category['name']
                        ]
                    ];
                }
                
                return [
                    'objects' => $objects
                ];
            } else {
                self::logMessage("データベースからカテゴリ取得結果が空", 'WARNING');
                return [];
            }
        } catch (Exception $e) {
            self::logMessage("データベースからカテゴリ取得エラー: " . $e->getMessage(), 'ERROR');
            Utils::log("データベースからカテゴリ取得エラー: " . $e->getMessage(), 'ERROR', 'SquareService');
            return [];
        }
    }
} 